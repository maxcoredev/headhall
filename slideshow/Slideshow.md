# ВЕДЁМ ПАЛЬЦЕМ

1. Сначала ничего не делаем, ждём провода по 10px (MIN_DISTANCE_TO_INTENT_[LEAF|CLOSE]),
чтобы понять — это горизонтальное листание или вертикальное закрытие.
2. Как только прошли 10px и выяснили направление — начинаем скролить,
умножая движения пользователя на [SLIDING|CLOSING]_BOOST_COEF (так в телеге)

Если скролл оказался горизонтальный — значит — листаем.
    (Не даём проскролить таким медленным образом более чем на 90% (STOP_SLIDING_ON_PERCENT_RICH) (так в телеге, и это клёво)
    Если отпустим мышку, и отлистали больше половины — перелистнём. Иначе — вернём картинку обратно.
    Если пролистали чуть-чуть, но с ускорением (PIXELS_PER_MOVE_TO_CONSIDER_SWIPE_[LEAF|CLOSE]) —
    перелистываем принудительно, даже если прошли малое расстояние.
Если скролл оказался — вертикальный — значит — хотим закрыть.
    Если отпустим мышку, и отлистали больше половины — закроем. Иначе — вернём картину обратно.
    Если пролистали чуть-чуть, но с ускорением (PIXELS_PER_MOVE_TO_CONSIDER_SWIPE_[LEAF|CLOSE]) — закрываем принудительно, даже если прошли малое расстояние.

# ТОНКИЕ МОМЕНТЫ

    1.
    Пользователь может дёрнуть так быстро, что браузер не фиксирует движение как плавное,
    не как X + 1, а как X + 2, или 3, 4, и вплоть до + 20.
    Опираясь на это — мы и определяем Намерение Свайпнуть.
    Подробнее в reset_pixels_per_move_coefs()

    2.
    Пользователь может — начать скролить в однУ сторону, и проскролить очень далеко,
    а потом резко свайпнуть в противоположную сторону.
    Подробнее в swipe_leaf() и swipe_close()

# СПОСОБЫ РЕАЛИЗАЦИИ

Обычно делают так:
    Ловим все возможные события — mousedown, mousemove, mouseup и т.д.
    И, к примеру в mousemove проверяем — если мышка не нажата `if (!is_mousedown) return;`.
Мы пошли другим путём:
    У нас по умолчанию навешено только одно событие — mousedown.
    И вот если мы нажмём — тогда навешиваем все побочные события. Чтобы без всех этих проверок.

# НАША РЕАЛИЗАЦИЯ

В тот момент когда мы отпускаем мышку (mouseup) —
надо не только удалить все побочные события,
но и сказать, что мы больше, к примеру — не листаем, т.е. is_dragging = false.

Но, у нас есть ещё и «стрелочки», которыми тоже можно листать.
Стрелочки у нас широкие, и, когда мы тянем по области стрелочек — очевидно — стрелочка должна перестать работать.
Но как по отпусканию мышки сказать стрелочке, что ей ничего делать не надо?

Слайдер работает по onclick (т.е. и нажать и отпустить мы должны в области стрелочки)
И, по спецификации, все события onclick вызывается позже событий mouseup,
когда все слайдинг-события уже отработали, события удалены, переменные обнулены.

- Может закрасться идея, что поможет переход от bubbling к capturing, но — нет,
bubbling и capturing работают среди определённого типа событий, а mouseup и click — разные события.
- Может закрасться идея сделать слайдер по onclick вместо mousedown/mouseup, но как мы тогда поймём что можно move?

Поэтому, единственное что остаётся — добавить слайдеру onclick, чисто для сброса переменных после вообще всего.
Таким образом onclick по стрелочкам отработает раньше чем onclick по слайдеру.
И, если происходили какие-то другие действия, то стрелочки будут об этом знать, и не будут отрабатывать.
Потому что отменяем события и обнуляем переменные мы их в onclick по слайдеру.

Но, на телефоне возможен и сценарий, когда пользователь, драгал, и вышел пальцем за пределы экрана.
Тут конечно никакого click не произойдёт. Но, это успешно обрабатывается иным способом.
Подробнее в perform_intention_on_touch_end().
(На десктопе всё проще — там есть mouseleave.)

# CLICK-OUTSIDE

Актально только для десктопа, потому что на телефоне этого нет, там — свайп и крестик.

Допустим, мы что-то листаем перетаскиванием, или листаем нажимая на стрелочки/превьюшки.
Соответственно — каждый раз нажимаем и на фон.
В то время как простое нажатие на фон — должно закрыть слайдшоу.
При этом, при обычном листании (из-за [SLIDING|CLOSING]_BOOST_COEF), и уж тем более при свайпинге,
мы можем отпустить мышку в тот момент, когда курсор будет находится между слайдами.

Мы могли бы сделать как-то так, чтобы:
когда мы и нажали непосредственно на голый фон, при этом,
когда и отпустили именно будучи на голом фоне — тогда и закрывать слайдшоу.
Но, разметка может быть разной, и, могут быть элементы, которые невидимы, но перекрывают фон,
к примеру — контейнер, где лежит крестик, контейнер с превьюшками, даже сами слайды могут лежать в
контейнере, вытянутом на всю ширину.

Соответственно, нужно сделать так, чтобы слайдшоу закрывалось тогда,
когда мы и нажали на не активный элемент, и отпустили мышку, будучи на любом другом неактивном элементе.
Мы могли бы воспользоваться `getEventListeners(element)`, но, это чисто Хромовская функция.

Выделим все активные элементы data-атрибутом data-prevent-click-outside.

# ТЕРМИНОЛОГИЯ КОМПОНЕНТА

Slideshow — весь этот компонент. Содержит сам Slider, обработку click-outside, pinch-zoom и т.д 
Slider — бОльшая часть компонента Slideshow — в нём вся основная движуха.

# ТЕРМИНОЛОГИЯ ДЕЙСТВИЙ (ПРОВОЦИРУЮТСЯ ПОЛЬЗОВАТЕЛЕМ)

Dragging — простое бездушное действие — зажали и медленно тащим (и пока не понятно в каком направлении, потому что можем по кривой).
Leafing — dragging по горизонтали.
Closing — dragging по вертикали.

Но есть 3 несамостоятельных группы действий:

    1. Манеры (manners):
        Slide — когда мы медленно драгали, а потом отпуслили палец. И пока ещё не знаем что произойдёт.
        Swipe — когда мы резко протащили и отпустили палец. И тоже не знаем что произойдёт.
    
    2. Намерения (intention)
        Leaf — пытаемся перелистнуть на следующий/предыдущий слайд. И не важно как — Slide или Swipe или вообще стрелочками/превьюшками.
        Close — пытаемся закрыть. Тоже не важно как — Slide или Swipe.
    
    3. Back — возвращение на исходный слайд после неуспеха.

    Но, все они бессмысленны друг без друга. Поэтому пораждают комбинации:

Самостоятельные действия:

    1. slide_leaf — успешное медленное перелистывание
    2. slide_leaf_back — медленно листали, но отлистали мало и вернулись назад
    3. swipe_leaf — успешное быстрое перелистывание
    4. swipe_leaf_back — медленно куда-то листали, а потом резко свайпнули в обратном направлении
    5. slide_close — успешное медленное закрытие
    6. slide_close_back — медленно закрывали, но отлистали мало и вернулись назад
    7. swipe_close — успешное быстрое закрытие
    8. swipe_close_back — медленно куда-то листали, а потом резко свайпнули в обратном направлении

# ТЕРМИНОЛОГИЯ ДВИЖЕНИЙ (ВЫЗЫВАЮТСЯ АЛГОРИТМОМ)

Scroll (прокручивать) — определяет: куда двигаться по горизонтали (куда хотили или обратно); с какой скоростью; запускает анимацию; меняет current_slide_index. (Меняет браузерный scrollLeft.)
    scroll — универсальные функции, принимающие манеру
    slide_scroll — когда мы точно знаем, что скролим скольжением
    swipe_scroll — когда мы точно знаем, что скролим по свайпу 

Nod (кивать) — определяет: куда двигаться по вертикали (куда хотили или обратно); с какой скоростью; запускает анимацию; закрывает весь Slideshow. (Меняет position-top и opacity.)
    nod — универсальные функции, принимающие манеру
    slide_nod — когда мы точно знаем, что киваем скольжением
    swipe_nod — когда мы точно знаем, что киваем по свайпу

Animate — бездушное движение от точки А к точке Б с определённой скоростью. После работы может вызывать callback, к примеру — смена индекса слайда. Чтобы можно было подсветить нужную thumbnail именно по успешному завершению анимации.

# ДОПОЛНИТЕЛЬНАЯ ТЕРМИНОЛОГИЯ

- В то время как пользователь может осуществлять Намерения (intention), алгоритм может Счесть что-то (consider).
- Фигурирует также «boost» — это не «ускорение» (acceleration). Ускорения у нас вообще нет. В нашем случае — «boost» — то, на сколько единовременно увеличится скорость от базовой. Т.е. это — «шаг ускорения».
- «move» — движение пальцем или мышкой. Могут интересовать 2 значения — сколько мы продвигали с самого начала драгинка, или — сколько pixels_per_move мы зафиксировали при резком рывке.
